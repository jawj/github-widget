// Generated by CoffeeScript 1.10.0

/*
 * to minify:
java -jar /usr/local/closure-compiler/compiler.jar \
  --compilation_level SIMPLE_OPTIMIZATIONS \
  --js github-widget.js \
  --js_output_file github-widget.min.js
 */


/** @preserve https://github.com/jawj/github-widget
Copyright (c) 2011 - 2012 George MacKerron
Released under the MIT licence: http://opensource.org/licenses/mit-license
 */

(function() {
  var cls, get, init, jsonp, make, makeWidget, text,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    hasProp = {}.hasOwnProperty;

  makeWidget = function(repos, div) {
    var i, len, repo, results;
    make({
      cls: 'gw-clearer',
      prevSib: div
    });
    results = [];
    for (i = 0, len = repos.length; i < len; i++) {
      repo = repos[i];
      results.push(make({
        parent: div,
        cls: 'gw-repo-outer',
        kids: [
          make({
            cls: 'gw-repo',
            kids: [
              make({
                cls: 'gw-title',
                kids: [
                  make({
                    tag: 'ul',
                    cls: 'gw-stats',
                    kids: [
                      make({
                        tag: 'li',
                        text: repo.watchers,
                        cls: 'gw-watchers'
                      }), make({
                        tag: 'li',
                        text: repo.forks,
                        cls: 'gw-forks'
                      })
                    ]
                  }), make({
                    tag: 'a',
                    href: repo.html_url,
                    text: repo.name,
                    cls: 'gw-name'
                  })
                ]
              }), repo.language != null ? make({
                cls: 'gw-lang',
                text: repo.language
              }) : void 0, make({
                cls: 'gw-repo-desc',
                text: repo.description
              })
            ]
          })
        ]
      }));
    }
    return results;
  };

  init = function() {
    var div, i, len, ref, results;
    ref = get({
      tag: 'div',
      cls: 'github-widget'
    });
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      div = ref[i];
      results.push((function(div) {
        var j, len1, limit, opts, repos, results1, sortBy, url, user, userCount, users;
        users = (div.getAttribute('data-user')).split(',');
        opts = div.getAttribute('data-options');
        opts = typeof opts === 'string' ? JSON.parse(opts) : {};
        sortBy = opts.sortBy || 'watchers';
        limit = parseInt(opts.limit) || Infinity;
        repos = [];
        userCount = 0;
        results1 = [];
        for (j = 0, len1 = users.length; j < len1; j++) {
          user = users[j];
          url = "https://api.github.com/users/" + user + "/repos?callback=<cb>";
          results1.push(jsonp({
            url: url,
            success: function(payload) {
              var first_repo, l, len2, ref1, ref2, repo, siteRepoNames, userName;
              if (payload.data.length > 0) {
                first_repo = payload.data[0];
                userName = first_repo.owner.login;
                siteRepoNames = [(userName + ".github.com").toLowerCase(), (userName + ".github.io").toLowerCase()];
                ref1 = payload.data;
                for (l = 0, len2 = ref1.length; l < len2; l++) {
                  repo = ref1[l];
                  if ((!opts.forks && repo.fork) || (ref2 = repo.name.toLowerCase(), indexOf.call(siteRepoNames, ref2) >= 0) || !repo.description) {
                    continue;
                  }
                  repos.push(repo);
                }
                userCount++;
                if (userCount === users.length) {
                  repos = repos.sort(function(a, b) {
                    return b[sortBy] - a[sortBy];
                  });
                  repos = repos.slice(0, +(limit - 1) + 1 || 9e9);
                  return makeWidget(repos, div);
                }
              }
            }
          }));
        }
        return results1;
      })(div));
    }
    return results;
  };

  cls = function(el, opts) {
    var c, classHash, classes, hasClasses, i, j, len, len1, ref;
    if (opts == null) {
      opts = {};
    }
    classHash = {};
    classes = el.className.match(cls.re);
    if (classes != null) {
      for (i = 0, len = classes.length; i < len; i++) {
        c = classes[i];
        classHash[c] = true;
      }
    }
    hasClasses = (ref = opts.has) != null ? ref.match(cls.re) : void 0;
    if (hasClasses != null) {
      for (j = 0, len1 = hasClasses.length; j < len1; j++) {
        c = hasClasses[j];
        if (!classHash[c]) {
          return false;
        }
      }
      return true;
    }
    return null;
  };

  cls.re = /\S+/g;

  get = function(opts) {
    var el, els, hasCls, inside, ref, ref1, ref2, ref3, tag;
    if (opts == null) {
      opts = {};
    }
    inside = (ref = opts.inside) != null ? ref : document;
    tag = (ref1 = opts.tag) != null ? ref1 : '*';
    if (opts.id != null) {
      return inside.getElementById(opts.id);
    }
    hasCls = opts.cls != null;
    if (hasCls && tag === '*' && (inside.getElementsByClassName != null)) {
      return inside.getElementsByClassName(opts.cls);
    }
    els = inside.getElementsByTagName(tag);
    if (hasCls) {
      els = (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = els.length; i < len; i++) {
          el = els[i];
          if (cls(el, {
            has: opts.cls
          })) {
            results.push(el);
          }
        }
        return results;
      })();
    }
    if ((opts.multi == null) && (ref2 = tag.toLowerCase(), indexOf.call(get.uniqueTags, ref2) >= 0)) {
      return (ref3 = els[0]) != null ? ref3 : null;
    } else {
      return els;
    }
  };

  get.uniqueTags = 'html body frameset head title base'.split(' ');

  text = function(t) {
    return document.createTextNode('' + t);
  };

  make = function(opts) {
    var c, i, k, len, ref, t, v;
    if (opts == null) {
      opts = {};
    }
    t = document.createElement((ref = opts.tag) != null ? ref : 'div');
    for (k in opts) {
      if (!hasProp.call(opts, k)) continue;
      v = opts[k];
      switch (k) {
        case 'tag':
          continue;
        case 'parent':
          v.appendChild(t);
          break;
        case 'kids':
          for (i = 0, len = v.length; i < len; i++) {
            c = v[i];
            if (c != null) {
              t.appendChild(c);
            }
          }
          break;
        case 'prevSib':
          v.parentNode.insertBefore(t, v.nextSibling);
          break;
        case 'text':
          t.appendChild(text(v));
          break;
        case 'cls':
          t.className = v;
          break;
        default:
          t[k] = v;
      }
    }
    return t;
  };

  jsonp = function(opts) {
    var callbackName, ref, ref1, url;
    callbackName = (ref = opts.callback) != null ? ref : '_JSONPCallback_' + jsonp.callbackNum++;
    url = opts.url.replace('<cb>', callbackName);
    window[callbackName] = (ref1 = opts.success) != null ? ref1 : jsonp.noop;
    return make({
      tag: 'script',
      src: url,
      parent: get({
        tag: 'head'
      })
    });
  };

  jsonp.callbackNum = 0;

  jsonp.noop = function() {};

  init();

}).call(this);
